@page "/"
@using System.Text.Json
@using Radar_Frontend.Models
@using Radar_Frontend.Components.Utilities.Services
@using global::Radar_Frontend.Models
@inject MqttService mqttService

<PageTitle>Home</PageTitle>

<MudPaper Class="p-4 d-flex flex-column align-items-center" Elevation="3" Style="max-width:900px;margin:0 auto;">
	<MudText Typo="Typo.h4" Class="mb-2">IoT Radar</MudText>

	<div id="radar" class="radar">
		<div class="sweep" />
		@foreach (var blip in Blips)
		{
			<div class="blip" style="left:@blip.Left; top:@blip.Top; opacity:1"></div>
		}
	</div>

	<div class="d-flex gap-2 mt-3">
		<MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="RefreshBlips">Scan</MudButton>
	</div>
</MudPaper>

@code {

	// --- Blip class with lifecycle ---
	class BlipPos
	{
		public string Left { get; set; } = "0px";
		public string Top { get; set; } = "0px";
		public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
	}

	List<BlipPos> Blips = new();

	protected override async Task OnInitializedAsync()
	{
		try
		{
			await mqttService.ConnectAsync();
			await mqttService.SubscribeAsync("radar/distance");
		}
		catch (Exception ex)
		{
			Console.WriteLine($"MQTT subscription failed: {ex.Message}");
		}

		mqttService.OnMessageReceived += (payload) =>
		{
			Console.WriteLine($"MQTT Message received with payload: {payload}");
			try
			{
				var radarData = JsonSerializer.Deserialize<RadarData>(payload);
				if (radarData != null)
				{
					// Sensor 1 at rotation angle
					AddBlip(radarData);
				}
			}
			catch (Exception ex)
			{
				Console.WriteLine($"Failed to parse MQTT payload: {ex.Message}");
			}

			CleanupBlips();
			Task.Delay(1);
			InvokeAsync(StateHasChanged);
		};

		// Start periodic cleanup
		var timer = new System.Threading.Timer(_ =>
		{
			CleanupBlips();
			InvokeAsync(StateHasChanged);
		}, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
	}

	void AddBlip(RadarData radar)
	{
		const double size = 480.0;
		const double cx = size / 2.0;
		const double cy = size / 2.0;
		const double radius = size / 2.0 * 0.88;
		const double blipHalf = 6.0;

		for (int i = 0; i < 2; i++)
		{
			var sensor = (i == 0) ? radar.SensorData1 : radar.SensorData2;
			if (sensor == null) continue;

			int angleDeg = radar.Rotation + (i == 1 ? 180 : 0);
			double angleRad = (angleDeg % 360) * Math.PI / 180.0;

			double r = Math.Min(sensor.DistanceMeasured, radius);
			double x = cx + r * Math.Cos(angleRad) - blipHalf;
			double y = cy + r * Math.Sin(angleRad) - blipHalf;

			// Convert Unix timestamp (assume seconds; if ms, use FromUnixTimeMilliseconds)
			DateTime createdAt = DateTimeOffset.FromUnixTimeSeconds(radar.Timestamp).UtcDateTime;

			Blips.Add(new BlipPos
			{
				Left = $"{x:F1}px",
				Top = $"{y:F1}px",
				CreatedAt = createdAt
			});
		}
	}



	void CleanupBlips()
	{
		var cutoff = DateTime.UtcNow.AddSeconds(-10);
		Blips = Blips.Where(b => b.CreatedAt > cutoff).ToList();
	}

	void RefreshBlips()
	{
		Blips.Clear();
		var rnd = new Random();
		var size = 480.0;
		var cx = size / 2.0;
		var cy = size / 2.0;
		var radius = size / 2.0 * 0.88;

		for (int i = 0; i < 5; i++)
		{
			var angle = rnd.NextDouble() * Math.PI * 2.0;
			var r = Math.Sqrt(rnd.NextDouble()) * radius;
			var x = cx + r * Math.Cos(angle) - 6;
			var y = cy + r * Math.Sin(angle) - 6;
			Blips.Add(new BlipPos { Left = $"{x}px", Top = $"{y}px", CreatedAt = DateTime.UtcNow });
		}
		StateHasChanged();
	}
}